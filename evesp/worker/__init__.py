from enum import Enum
from threading import Thread

from evesp.action import Action
from evesp.bus import Bus
from evesp.event import StopEvent
from evesp.utils import *

class WorkerState(Enum):
    not_initialized = 'Not Initialized'
    initialized = 'Initialized'
    starting = 'Starting'
    running = 'Running'
    stopped = 'Stopped'

class Worker(object):
    """
    Worker base class.

    A worker is a thread spawned by an engine which can run the logic of an
    actuator.

    An engine usually spawns a pool of workers, an they communicate to each
    other over two queues.

    action_bus - A queue of actions passed by the engine to the worker.

    value_bus - A queue of returned values, passed by the worker back to the
    engine when the code of the actuator (with a unique ID passed by the
    engine) has been executed.

    Fabio Manganiello, 2015 <blacklight86@gmail.com>
    """

    def __init__(self):
        """
        Constructor. It will build:

        action_bus -- Bus object connected to the engine. The actions will be
        passed by the engine over here. Each object will have its unique ID
        generated by the engine and used to track the lifecycle of the action
        and the values it returns back to the engine.

        value_bus -- Bus object connected to the engine. The values of the
        actions run by the worker will be passed here together with their
        original action IDs.
        """

        self.state = WorkerState.not_initialized
        self.action_bus = Bus()
        self.value_bus = Bus()
        self.state = WorkerState.initialized

    def start(self, actions_to_run=None):
        """
        Start the worker, which then polls action_bus for actions to run.

        actions_to_run -- If set, the worker will stop after having processed that
        number of actions.  Otherwise, it will forever loop for actions on the
        bus to process.
        """

        self.state = WorkerState.starting
        self.__thread = Thread(target = self.__run, args=[actions_to_run])
        self.__thread.start()

    def __run(self, actions_to_run):
        self.state = WorkerState.running
        n_actions = 0

        while actions_to_run is None or n_actions < actions_to_run:
            act = self.action_bus.next()
            n_actions += 1

            if isinstance(act, StopEvent):
                # If the worker received a stop event from the bus, exit immediately
                self.state = WorkerState.stopped
                break

            assert isinstance(act, Action)
            act.run()

            # #### #
            # TODO #
            # #### #

# vim:sw=4:ts=4:et:

